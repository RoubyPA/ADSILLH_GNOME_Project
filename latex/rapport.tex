\documentclass[12pt]{report}
%% Language and font encodings
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\usepackage[svgnames]{xcolor}
\usepackage{float} % figure
\usepackage{eurosym} % euro character
\usepackage{minted} % syntax coloring

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

%% Syntax color for minted code blocks
\usemintedstyle{tango}

\title{Projet Licence ADSILLH 2017/2018\\Rapport}
\author{\textbf{Groupe Games}: Pierre Antoine Rouby - Gautier Delacour - David Tabarie\\
  \textbf{Groupe Music}: Kevine Carsoule - Florian Darfeuille\newline}

\date{Année 2017/2018}

%%\begin{document}
%%  \begin{figure}
%%    \includegraphics[scale=0.5]{images/logo_univ.jpg}
%%  \end{figure}
%%  \begin{center}
%%    \textbf{Groupe Games}:\\ Pierre Antoine Rouby\\ Gautier Delacour\\David Tabarie\\ \textbf{Groupe Music}:\\ Kevine Carsoule\\ Adrien Darfeuille
%%    \end{center}
%%  \begin{figure}
%%    \includegraphics[scale=0.5]{images/Gnomelogo_svg.jpg}
%%  \end{figure}
%%\maketitle
\begin{document}
\makeatletter
\begin{titlepage}
  \centering
  \begin{figure}
    \centering
    \vspace{1cm}
    \textcolor{SteelBlue}{\fbox{\Huge{\emph{\textbf{Rapport de projet}}}}}\\
    % FireBrick, DarkRed, Indigo.
    \vspace{-5cm}
  \end{figure}


  \begin{figure}
    \centering
    \vspace{14cm}
          % FireBrick, DarkRed, Indigo.
          \vspace{2cm}
          \includegraphics[scale=0.2]{images/Gnomelogo_svg.png}
    \vspace{-15cm}
  \end{figure}

  
  \begin{flushleft}
    \centering
    \large{\textbf{Projet GNOME}} :\\{\@author}\\ 
    Licence ADSILLH\\
    Session 2017
  \end{flushleft}


  \vspace{15cm}
  %%\Large{Lycée Alfred Kastler}\\
  %%\normalsize{\textcolor{Peru}{14 Avenue de l'Université\\33402 Talence}}


  \vspace{-0.1cm}
  \centering\includegraphics[scale=0.3]{images/logo_univ.jpg}
  
\end{titlepage}
\makeatother


% We can't place a logo on titlepage
% \begin{titlepage}
%   \includegraphics[scale=0.3]{images/logo_univ.jpg}
% \end{titlepage}

\begin{abstract}
Ce document présente les différentes contributions effectuées dans le
cadre du projet sous licence libre de la licence ADSILLH. Le but est
avant tout de nous accoutumer au développement collaboratif, et de
nous apprendre à interagir avec une communauté du logiciel libre.
\end{abstract}

\tableofcontents

\chapter{Le projet GNOME}
\section{Présentation}
% from: https://fr.wikipedia.org/wiki/GNOME
% Gautier : j'ai enlevé le terme ``environnement de bureau livre convivial'', ce n'est pas un terme objectif
% PA: L'objectivité existe t'elle ?
GNOME, acronyme de GNU Network Object Model Environment, est un
environnement de bureau libre  dont l'objectif est de rendre
accessible l'utilisation du système d'exploitation GNU au plus grand
nombre ; cette interface est actuellement populaire sur les systèmes
GNU/Linux et fonctionne également sur la plupart des systèmes de type
UNIX.

GNOME est développé par The GNOME Project dont les participants sont
bénévoles ou rémunérés par des entreprises externes au projet. La
majorité du travail est fournie par les contributeurs professionnels,
en premier lieu ceux travaillant pour Red Hat.

Dans ce document nous n'utiliserons pas forcément les noms complets des
projets, étant donné que nous somme dans le contexte de GNOME nous
simplifieront les noms en supprimant le terme GNOME.
Exemple: Gnome-Builder pourra être simplifié par Builder.

\section{Les outils collaboratifs} 
% TODO PA: Cette partie a besion d'une relecture ;)
\subsection{Bugzilla}
\label{bugzilla}
% from: https://fr.wikipedia.org/wiki/Bugzilla
Bugzilla est une solution de gestion de bugs, distribuée sous
% form: https://fr.wikipedia.org/wiki/Double_licence
tri-licence\footnote{Tri-licence: Le concept de licence multiple
  est de proposer un travail non pas sous une licence unique, mais
  en offrant un choix restreint de licence, pour permettre une plus
  grande flexibilité. 
  (\url{https://fr.wikipedia.org/wiki/Licence_multiple})}
MPL\footnote{MPL: Mozilla Public License 
  (\url{https://www.mozilla.org/en-US/MPL/})}
/ GNU GPL\footnote{GNU GPL: GNU General Public License 
  (\url{https://www.gnu.org/licenses/gpl.html})}
/ GNU LGPL\footnote{GNU LGPL: GNU Lesser General Public License 
  (\url{https://www.gnu.org/licenses/lgpl.html})}
, elle est développée et utilisée à l'origine par Mozilla.
GNOME a mis en place un bugzilla (\url{https://bugzilla.gnome.org}) pour 
la gestion des bugs dans les différents projets.
%% (figure~\ref{figure_bugzilla} page~\pageref{figure_bugzilla})

%% \newline
%% % from: https://bugzilla.gnome.org/page.cgi?id=points.html
%% Bugzilla intègre aussi une fonctionnalité de "score"
%% %% (figure~\ref{figure_bugzilla_score} page~\pageref{figure_bugzilla_score})
%% , dont le but est a l'origine d'avoir une idée 
%% aproximative de l'activité d'une personne  sur le bugzilla, et donc 
%% des personnes qui sont le plus experimenté pour aidée les autres 
%% utilisateurs. Mais ce dispositif s'est revelé peu efficace. Le
%% score est donc plus une fonctionnalite un peut fun qu'un vrai outils.
%% A noter qu'il existe quand même un classement de la semaine, disponible 
%% \href{https://bugzilla.gnome.org/page.cgi?id=weekly-bug-summary.html}{ici}.

\subsection{Wiki}
\label{wiki}
GNOME dispose d'un wiki (\href{https://wiki.gnome.org/}{wiki.gnome.org})
où l'on peut retrouver les documentations sur les différents projets.
%% (figure~\ref{figure_wiki} page~\pageref{figure_wiki}).

\subsection{Git}
\label{git}

\label{cgit}
Le projet GNOME dispose de plusieurs interfaces Git. L'interface 
principale est basée sur le logiciel libre "cgit"
%% (figure~\ref{figure_cgit} page~\pageref{figure_cgit})
, on peut y retrouver la plupart des projets GNOME 
(\href{https://git.gnome.org/}{git.gnome.org}). Pour créer un bug il faut
passer par Bugzilla (section~\ref{bugzilla} page~\pageref{bugzilla}).

\label{gitlab}
GNOME a aussi mis en place un GitLab (\href{https://gitlab.gnome.org/GNOME}
{gitlab.gnome.org}) ou l'on peut trouver de nombreux projets. L'interface
est plus moderne, par exemple nous pouvons créer des "Pull Requests" comme
sur github et le report de bug est sur l'interface gitlab, donc pas besoin
de passer par le Bugzilla. Il est aussi possible de parcourir le code via
l'interface web de gitlab.
%% (figure~\ref{figure_gitlab} page~\pageref{figure_gitlab}).

\label{github}
Il existe aussi un miroir des répertoires git des projets GNOME sur GitHub 
(\href{https://github.com/GNOME}{github.com/GNOME}).

\subsection{IRC}
Le projet GNOME dispose aussi d'un chat irc (\url{irc.gnome.org})
avec de nombreux salons, dont voici quelque exemples :
\begin{itemize}
\item \#gnome-hacker : Pour les discussions sur le développement de GNOME ;
\item \#newcomers : Pour les nouveaux contributeurs au projet ;
\item \#gnome-games : Pour les discutions autour du projet Games ;
\item \#vala : Spécifique pour le langage vala.
\end{itemize}

\subsection{Mailing lists}
Des mailing lists sont aussi à notre disposition pour se tenir informé.
% PA: TODO Useful ?

\subsection{Newcomers}
Le projet GNOME met à disposition sur son site un guide pour les nouveaux
arrivants souhaitant contribuer au projet.Cette section nous propose
tout d'abord le chat irc dédié aux nouveaux contributeurs, ainsi que la
mailing list qui leur ai réservée
(\url{https://mail.gnome.org/mailman/listinfo/newscomers-list}).

Quelques conseils sont aussi donnés: patience,respect des autres et prise
d'initiatives sont des qualités nécessaires au bon fonctionnement du projet.

Il est ensuite présenté Flatpack qui permet d'installer Builder.
C'est un environnement de développement intégré qui permet de travailler
sur les applications GNOME. Il permet de télécharger les sources d'un
projet et de pouvoir travailler dessus et de le construire grâce à une
interface graphique simplifiée. Il permet en effet d'éditer des fichiers
ou de compiler le projet avec un seul bouton, de gérer les dépendances
et met à disposition un débogueur.

On nous présente ensuite la documentation disponible sur
\url{https://developper.gnome.org/search}
ainsi que sur la page du projet concerné. On nous explique ensuite que
chaque projet possède des bugs dédiés aux newcomers. Ce sont des bugs
qui permettent aux nouveaux arrivants de se familiariser à la fois avec
le code et avec la manière de corriger un bug grâce à des bugs pas trop
complexes.

Le guide aiguille ensuite le nouvel arrivant sur la façon de corriger
un bug en comprenant ce qu'il se passe et en changeant le code de
façon à le corriger. Enfin le guide nous montre comment créer un
patch depuis le commit et le poster sur le bug report sur bugzilla.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GNOME-Music
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{GNOME-Music}
GNOME Music est une application permettant d'écouter de la musique, 
son interface se veut particulièrement simple afin de permettre aux
utilisateurs de gérer facilement leur musique, leur bibliothèques, 
les recherches et la lecture de leur fichiers audio.
Les sources du projet sont disponibles sur github 
(\url{https://github.com/GNOME/gnome-music}).

\section{Le langage Python}
% https://fr.wikipedia.org/wiki/Python_(langage)
Le projet est écrit dans le langage Python. C'est un langage de
programmation objet, multi-paradigme et multiplateformes. Il favorise la
programmation impérative structurée, fonctionnelle et orientée objet. 
Il est doté d'un typage dynamique fort, d'une gestion automatique de la 
mémoire par ramasse-miettes et d'un système de gestion d'exceptions ; 
il est ainsi similaire à Perl, Ruby, Scheme, Smalltalk et Tcl.

Python est un langage qui peut s'utiliser dans de nombreux contextes 
et s'adapter à tout type d'utilisation grâce à des bibliothèques 
spécialisées. Il est cependant particulièrement utilisé comme 
langage de script pour automatiser des tâches simples mais 
fastidieuses, comme un script qui récupérerait la météo sur Internet 
ou qui s'intégrerait dans un logiciel de conception assistée par 
ordinateur afin d'automatiser certains enchaînements d'actions 
répétitives (voir la section Adoption). On l'utilise également comme 
langage de développement de prototype lorsqu'on a besoin d'une 
application fonctionnelle avant de l'optimiser avec un langage 
de plus bas niveau. Il est particulièrement répandu dans le monde 
scientifique, et possède de nombreuses extensions destinées au 
calcul numérique.

Python a été conçu pour être un langage lisible. Il vise à être 
visuellement épuré. Par exemple, il possède moins de constructions 
syntaxiques que de nombreux langages structurés tels que C, 
Perl, ou Pascal. Les commentaires sont indiqués par le caractère 
croisillon (\#).

Les blocs sont identifiés par l'indentation, au lieu d'accolades 
comme en C ou C++ ; ou de begin ... end comme en Pascal ou Ruby. 
Une augmentation de l'indentation marque le début d'un bloc, et 
une réduction de l'indentation marque la fin du bloc courant. 

\section{Premiers pas avec le projet}
\subsection{Compilation 1ere Partie}
Lorsque nous avons voulu compiler le projet nous avons rencontré 
beaucoup de problèmes notamment ceux liés aux dépendances nécessaires
à la compilation. Ces dépendances là ne sont pas indiquées dans la
documentation et nous devions alors les installer une par une à
mesure ou nous ne pouvions nous rendre compte des dépendances 
manquantes que lors de la compilation. 
Nous avons ensuite eu un problème avec le paquet libtracker-sparql
qui bien qu'étant installé n’était pas considéré comme tel.

\subsection{GNOME Builder}
Nous sommes ensuite passé sur GNOME Builder pour compiler le projet.
En effet grâce à cet environnement de développement intégré les 
dépendances sont gérées automatiquement. Cependant là aussi nous
avons rencontré des problèmes tout d'abord car les téléchargements
réalisés par GNOME Builder était trop gros pour nos VM puis nous 
nous avons rencontré un bug lors de l’exécution de l'application.
En effet lors de l'exécution de celle-ci depuis le builder l'application
ne s'affichait pas correctement, il n'y avait pas les boutons en haut
et le répertoire de musique n’était pas trouvé. Cela nous a mené à 
faire notre premier rapport de bug(Voir ci-après).

\subsection{Compilation 2eme Partie}
Nous étions alors sur Ubuntu depuis le début du projet et nous avons
décidé de passer sur debian sans utiliser GNOME Builder afin d'avoir 
une compilation plus facile. Ce fut le cas grâce notamment à la 
commande build-dep qui permet de récupérer toutes les dépendances d'un 
projet. Nous avons donc pu commencer à travailler sur projet en 
lui-même.

\section{Bug reports}
\subsection{Bug Report sur GNOME Builder}
Suite au bug constaté lors de l’exécution du logiciel depuis le Builder
nous avons réalisé un rapportde bug disponible sur 
\url{https://bugzilla.gnome.org/show_bug.cgi?id=790067}, où nous 
expliquions que lors du lancement du logiciel avec le Builder nous 
n'avions aucun bouton disponibles. Un contributeur nous a répondu que
le problème venait de la variable XDG\_MUSIC\_DIR qui n’était pas définie 
lors du lancement avec flatpack, cela empêchait l'application de trouver
l'emplacement du dossier où se trouvait la musique et donc aucun bouton
ne s'affichait sur la fenêtre. Une autre personne nous à répondu en 
ayant le même problème et en sachant pas comment changer cette variable.
Nous n'avons pour l'instant pas trouvé comment changer cette variable.

\section{Nos différents patchs}
\subsection{Pep8}
Le projet de GNOME-Music est un projet qui cherche à respecter la 
convention Pep8. C'est une convention qui a pour but de standardiser 
la syntaxe des code sources en  python. L'objectif est d’homogénéiser 
et de rendre plus lisibles les codes en langage python. Afin de tester 
si le code respectait bien la convention Pep8 nous avons utilisé l'outil
pycodestyle à qui on passe en paramètre les différents fichiers sources
et qui nous donne des erreurs là où la syntaxe ne respecte pas la 
convention pep8. Nous nous sommes rendu compte qu'il y a plusieurs erreurs
présentes dans les sources dont certaines de nombreuses fois comme le
cas des lignes trop longues. Dans un premier temps on à corriger des
erreurs dans différents fichiers mais ce n’était pas efficace car on 
ne corrigé pas un type d'erreurs dans tous les fichiers. Nous avons donc 
décider de nous concentrer sur les erreurs les moins fréquentes mais 
que lorsque nous nous occupions d'une erreur celle ci soit entièrement 
réglée. Nous avons donc posté un patch réglant les erreurs: E203, E712,
E111, E201, E202, E302 et E711 sur bugzilla et nous attendons un réponse 
des développeurs.

\subsection{Retour arrière avec la souris}
Un autre patch consistait à faire un retour arrière avec le bouton
"back" de la souris . Plus précisément, il s'agit d'un retour vers la
playlist depuis le menu album.  Une alternative existait déjà dans le
code avec le raccourci Alt+Left. Dans ce projet , les événements sont
gérés par le fichier "window.py" et par la libraire GTK . Néanmoins ,
seul les événements de clavier ont été implémentés. Il a donc fallu
qu'on connecte la reconnaissance des clics avec un ".connect" . Une
fois le "event.button" bien reconnu par la librairie GTK , nous avons
pu faire une boucle qui reconnaît le clic du bouton back (event==8) et
revient vers la playlist ( si et seulement si on se trouve dans Album
).

Voici un aperçu de notre modification de code : 

\begin{minted}[breaklines]{python}
  self.button_press_event_id = self.connect('button_press_event', self.button_press)

  def button_press(self,widget,event):
    #Go Back from Album with mouse button 
    if (event.button == 8):
      if (self.toolbar._state != ToolbarState.MAIN):
        self.curr_view.set_visible_child(self.curr_view._grid)
        self.toolbar.set_state(ToolbarState.MAIN)
\end{minted}

Une fois que cela est fait , on compile et on créé un backbutton.patch
qu'on envoie aux programmeur sur bugzilla .  Nous sommes actuellement
en attente d'une réponse des développeurs gnome-music .

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GNOME-Games
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\chapter{GNOME-Games} %% Change GNOME-Games to Games ?
Games est une application permettant la gestion d'une
bibliothèque vidéoludique. Elle est capable de s'interfacer avec de
nombreux émulateurs ainsi que les jeux natifs Linux. Au début du
projet Games étais disponible sur le git de GNOME, mais depuis peu il
a migré sur Gitlab.

\section{Les projets associés}
Le projet s'appuie sur plusieurs autre projets:
\begin{itemize}
\item retro-gtk : Développé initialement en Vala pour le projet Libretro, a
  été repris par le mainteneur de Games où il a réimplémenté certaines
  fonctions en C. De plus il a porté le système de build sous Meson.\\
  \url{http://bytesgnomeschozo.blogspot.fr/2017/10/retro-gtk-future-marty.html}\\
  Il a ensuite prévu de porter le projet en langage Rust
  \footnote{Projet retro-gtk : \url{https://gitlab.gnome.org/GNOME/retro-gtk}}.
\item libmanette : Libmannette est aussi développé pas le mainteneur de Games. Cette bibliothèque
  permet la gestion des manettes
  \footnote{Projet libmanette : \url{https://gitlab.gnome.org/aplazas/libmanette}}.
\end{itemize}

\section{Le langage Vala}
% from: https://fr.wikipedia.org/wiki/Vala_(langage)
Vala est un langage de programmation compilé, dont l'objectif est de
fournir les bénéfices des langages de programmation modernes (comme la
POO) aux développeurs de la plateforme GNOME qui utilisent GLib et son
système GObject.

Sa syntaxe est basée sur celle de C\# mais il ne nécessite pas
d'environnement d'exécution. Vala est transformé en code C, lui-même
compilé en code machine natif. Les avantages d'une telle chaîne de
compilation sont de produire des logiciels qui requièrent moins de
mémoire vive et qui s'exécutent plus rapidement.

De plus, ce passage par l'étape C rend possible l'utilisation des
bibliothèques C au moyen d'interfaces définies dans les fichiers
Vapi. Des fichiers Vapi sont fournis avec Vala pour une grande partie
de la plateforme GNOME, ainsi que pour d'autres bibliothèques.
\footnote{Source Vala: \url{https://fr.wikipedia.org/wiki/Vala_(langage)}}

\section{Le format Flatpak}
% from: https://fr.wikipedia.org/wiki/Flatpak
Flatpak, nommé xdg-app jusqu’en mai 2016, est un système de
virtualisation d’application pour les distributions GNU/Linux de
bureau.

L'objectif est de fournir un environnement « bac à sable » (sandbox)
sûr, isolé du reste du système, dans lequel les utilisateurs peuvent
exécuter des applications non validées par les dépôts de la
distribution (des versions de test, par exemple). Les applications
utilisent des appels de fonctions spécifiques fournies par xdg-app
pour contrôler les périphériques matériels ou accéder aux fichiers de
l'utilisateur, et xdg-app demande à l'utilisateur sa permission avant
de donner accès.

Le nom originel vient de freedesktop.org, qui est souvent abrégé en «
xdg », cette structure ayant hébergé sur ses serveurs le projet
xdg-app. En mai 2016, le projet a été rebaptisé « Flatpak ».

En juin 2016, un certain nombre d'applications connues sont portées en
format Flatpak, comme MonoDevelop, GNOME Shell, Pitivi ou LibreOffice.

Les applications Flatpak se téléchargent sous forme d'un fichier qui
peut s’exécuter directement sur le système, de façon indépendante de
la distribution Linux précise utilisée, sous réserve que le logiciel
Flatpak ait été préalablement installé sur cette distribution.

Pour permettre au « bac à sable » de fonctionner malgré son isolement
du système, il faut donc que les bibliothèques ou dépendances
indispensables à un logiciel soient embarquées avec lui au sein de son
paquet « Flatpak ». Ce système a pour inconvénient d'embarquer
potentiellement plusieurs fois la même bibliothèque (une par paquet
Flatpak), et donc de prendre plus de place. Il a par contre pour
avantage de ne pas déstabiliser un logiciel Flatpak lors d'une mise à
jour de dépendances ou de bibliothèques, puisque cette mise à jour ne
le concernera pas. Il est dès lors assez simple de faire cohabiter
plusieurs versions d'un même logiciel.
\footnote{Source Flatpak : \url{https://fr.wikipedia.org/wiki/Flatpak}}

\section{Découverte du logiciel}
\subsection{Compilation}
Nous avons utilisé Debian Sid comme OS de développement et de test,
et nous avons rencontrés de nombreux problèmes relatifs à la compilation,
cela étant en grande partie dû à l'utilisation de bibliothèques encore en
état de développement actif, ainsi qu'au système de configuration
``Meson'' qui est un remplacement de ``./configure''.\\

Ainsi il a été nécessaire de compiler certaines bibliothèques, parmi
lesquelles :
\begin{itemize}
\item retro-gtk
\item libmanette\\
\end{itemize}

De plus, aucun fichier ne documentait la procédure d'installation,
cela nous à particulièrement posé problème car nous ne nous
connaissions pas le système de build Meson
pour retro-gtk.

Nous avons aussi tenté d'utiliser l'IDE Builder, qui possède une
fonctionnalité permettant de télécharger automatiquement les
dépendances. Cependant nous n'avons pas réussi à l'utiliser sur la branche master,
car il ne pouvait pas trouver les bonnes bibliothèques (section~\ref{HACKING}
page~\pageref{HACKING}).

Lors de l'utilisation du logiciel, nous avons rencontré quelques
problèmes: certains jeux étaient chargés avec de mauvaises jaquettes,
et il était impossible de paramétrer les touches du clavier.

\section{Les bug reports}
% Gautier : système de statuts -> aucune explication
% Gautier : lecture de différents bug reports, et réécriture plus simple dans un
%           fichier partagé pour effectuer un premier tri
\subsection{Bug PulseAudio}
\label{PulseAudio}
Un bug avec PulseAudio (\url{https://bugzilla.gnome.org/show_bug.cgi?id=781887})
était déclaré pour Games, en effet le programme crashait quand le serveur
PulseAudio était éteint et que l'on tentait de lancer un jeu.

Il a donc fallu reproduire le bug, pour cela nous avons personnalisé notre
configuration PulseAudio pour qu'elle ne se relance pas automatiquement.
\begin{minted}[breaklines]{console}
/etc/pulse/client.conf:
   autospawn = no
\end{minted}

Nous avons aussi utilisé une commande pour simuler le crash du serveur PulseAudio.
\begin{minted}[breaklines]{console}
  $ PulseAudio --kill
\end{minted}

Le terminal retournait le message d'erreur suivant:
\begin{minted}[breaklines]{console}
Assertion 'p' failed at pulse/simple.c:273, function pa_simple_write(). Aborting.
\end{minted}

En vérifiant dans les sources de PulseAudio on retrouve bien l'``assert'' qui provoque
l’arrêt prématuré du programme.
\begin{minted}[breaklines]{c}
  pa_assert(p);
\end{minted}

A partir de là nous avons tracé le bug dans le code source de gnome-games et retro-gtk.
Pour cela nous avons commencé par utiliser la commande ``git grep'' pour retrouver
la (ou les) fonction(s) susceptible d'appeler ``pa\_simple\_write ()''.
\begin{minted}[breaklines]{console}
  $ git grep ``pa_simple_write''
\end{minted}

Aucune fonction n'a été trouvée dans les sources de Games, par contre il y a bien
une fonction qui fait appel à ``pa\_simple\_write'' dans retro-gtk.
Nous avons donc pu déterminer que la fonction
``retro\_pa\_player\_on\_audio\_output'' (définie dans le fichier
``retro\_pa\_player.c'' du projet ``retro-gtk'') appelle la fonction de PulseAudio
``pa\_simple\_write'' qui provoque le crash.

\begin{minted}[breaklines]{c}
  if (self->simple == NULL || sample_rate != self->sample_rate)
    retro_pa_player_prepare_for_sample_rate (self, sample_rate);

  pa_simple_write (self->simple, data, sizeof (gint16) * lenght, NULL);
\end{minted}
  
Après quelques tests et une vérification dans les sources nous  avons compris
que la fonction ``retro\_pa\_player\_prepare\_for\_sample\_rate'' retourne ``self''
équale à ``NULL'' si PulseAudio n'est pas disponible.

La solution la plus simple était de contourner la fonction ``pa\_simple\_write''
avec un test de la valeur de la structure et un ``return'' prématuré dans la fonction
appellante si la valeur est ``NULL''. Nous avons aussi pensé à afficher un message à
l'utilisateur et lui demandant si il voulais lancer quand même le jeux mais sans le son.

La première solution nous a paru trop simple et pas suffisament fiable, et la
seconde un peu trop compliquée à mettre en oeuvre sur un projet que l'on découvrait juste.
Nous avons donc décidés de poster sur le rapport de bug notre analyse du problème, et
d'attendre une décision du mainteneur.

Finalement le mainteneur a opté pour la première solution et a ajouté un test, comme
ci-desous:
\begin{minted}[breaklines]{c}
  if (self->simple == NULL || sample_rate != self->sample_rate)
    retro_pa_player_prepare_for_sample_rate (self, sample_rate);

  if (self->simple == NULL)
    return;

  pa_simple_write (self->simple, data, sizeof (gint16) * lenght, NULL);
\end{minted}

\section{Nos patchs}
% TODO PA: Cette partie a besion d'une relecture
\subsection{Mise à jour du fichier HACKING}
\label{HACKING}
Le premier patch que nous avons envoyé est en réponse à un bug report
(\url{http://bugzilla.gnome.org/show_bug.cgi?id=788692}), il ajoute une aide
pour la compilation du projet.

Il n'y avait aucune aide ou information dans la documentation sur la compilation
du projet. Étant nouveaux dans le projet GNOME nous n'avions pas connaissance de 
Builder qui permet assez simplement de construire le projet. Mais même avec cet
outil, la compilation s'est révélée ardue. En effet le fonctionnement de Builder a
tendance à changer entre les versions et certaines actions comme un ``git pull''
peuvent poser problème. Nous avons donc décidé de modifié le fichier HACKING du
projet pour y ajouter des instruction de compilation.

Le projet utilise pour le moment le système ``autotools'' pour sa configuration et 
sa compilation, mais pour la version 2.30 il est prévu qu'il passe à un système
avec le logiciel ``meson'' pour la configuration.

Après des recherches et un peu d'aide, nous avons réussi à avoir une procédure
complète pour la compilation du projet. L'une des difficultés que l'on peut
rencontrer pour la compilation de Games et qui est le sujet du bug report sur le
quelle nous avons répondu, est le fait que la version master de Games a besoin de
la version master de ``retro-gtk'' et ``libmannette''. Cette spécificité n'est
indiqué nulle part dans la documentation et les dépendances de ces deux
bibliothèques ne sont pas à jour dans la liste de dépendances d'autotools.

Nous avons nous-même rencontrés des problèmes de compilation, il nous a donc
semblé important de donner des indications pour que les prochaines personnes qui
voudraient contribuer ne soient pas freinées par un problème comme celui-ci.

Il y a eu de nombreux ajustements demandés par le mainteneur, notamment la demande
d'utilisation de la syntaxe Markdown.
Markdown est un langage de balisage léger fait pour être facile a lire est a écrire.
l'exemple ci-dessous permet d'écrire des ligne de commande shell :
\begin{verbatim}
  ```shell
  ./autogen.sh && ./configure
  ```
\end{verbatim}
Ou encore ci-dessous un exemple de lien :
\begin{verbatim}
  [Builder](https://wiki.gnome.org/Apps/Builder "GNOME-Builder Wiki")
\end{verbatim}

D'autre parties de notre patch original se sont revélées peut utiles ou pratiquement
impossible à maintenir. Nous voulions par exemple faire une liste exhaustive des
dépendances du projet, cette idée à étais refuser par le mainteneur car très
difficile a maintenir d'une version a l'autre.
Après plusieurs modifications et échanges avec le mainteneur le patch à étais
accepté et commité.

\subsection{Mise à jour du fichier README.md}
\label{README}
Le second patch (\url{http://bugzilla.gnome.org/show_bug.cgi?id=790454}) 
que nous avons envoyés, est une mise à jour de la documentation de retro-gtk.
En effet retro-gtk est passé d'un système de compilation 'autotools' à un
système avec le logiciel 'meson' et le compilateur 'ninja'.
Nous avons donc mis à jour le fichier README.md en respectant la syntaxe
'Marckdown', utilisé par github et gitlab par exemple.
Le patch n'a pas encore été accepté.

\subsection{Retour à la collection avec les touches Alt+Left}
Le but de ce patch (\url{https://gitlab.gnome.org/GNOME/gnome-games/issues/3})
est de lier un évent à une combinaison de touches (en l’occurrence Alt+Left).

En cherchant dans les fichiers source, nous avons remarqués qu'un
fichier XML référençait les events:

\begin{minted}[breaklines]{vala}
  <signal name="key-press-event" after="yes" handler="on_key_pressed"/>
\end{minted}

La fonction ``on\_key\_pressed'' se trouve dans le fichier
application-window.vala qui se trouve dans le répertoire src/ui .

\begin{minted}[breaklines]{vala}
  [GtkCallback]
  public bool on_key_pressed (Gdk.EventKey event) {
    var default_modifiers = Gtk.accelerator_get_default_mod_mask ();

    if ((event.keyval == Gdk.Key.q || event.keyval == Gdk.Key.Q) &&
    (event.state & default_modifiers) == Gdk.ModifierType.CONTROL_MASK) {
      if (!quit_game ())
      return false;

      destroy ();

      return true;
    }

    return handle_collection_key_event (event) || handle_display_key_event (event);
  }
\end{minted}

Une fonction permettant de retourner à la collection existait déjà:

\begin{minted}[breaklines]{vala}
private void on_display_back () {
  if (quit_game ())
  ui_state = UiState.COLLECTION;

  uninhibit (Gtk.ApplicationInhibitFlags.IDLE | Gtk.ApplicationInhibitFlags.LOGOUT);
}
\end{minted}

Une fonction qui gère les événements de certaines touches à des événements
était aussi déjà présente:

\begin{minted}[breaklines]{vala}
  private bool handle_display_key_event (Gdk.EventKey event) {
    if (ui_state != UiState.DISPLAY)
      return false;

    var default_modifiers = Gtk.accelerator_get_default_mod_mask ();

    if ((event.keyval == Gdk.Key.f || event.keyval == Gdk.Key.F) &&
    (event.state & default_modifiers) == Gdk.ModifierType.CONTROL_MASK &&
    display_header_bar.can_fullscreen) {
      is_fullscreen = !is_fullscreen;
      settings.set_boolean ("fullscreen", is_fullscreen);

      return true;
    }

    if (event.keyval == Gdk.Key.F11 && display_header_bar.can_fullscreen) {
      is_fullscreen = !is_fullscreen;
      settings.set_boolean ("fullscreen", is_fullscreen);

      return true;
    }

    if (event.keyval == Gdk.Key.Escape && display_header_bar.can_fullscreen) {
      is_fullscreen = false;
      settings.set_boolean ("fullscreen", false);

      return true;
    }
    
    return false;
  }
\end{minted}

C'est en prenant cet extrait pour exemple que nous avons ajouté une
condition dédiée à Alt+Left, il nous a été nécessaire de chercher dans
la documentation du langage Vala pour trouver la touche
correspondante.

Voici le code correspondant à notre patch:

\begin{minted}[breaklines]{vala}
  if (event.keyval == Gdk.Key.Left){			
    on_display_back ();
    
    return true;
  }
\end{minted}

Puis en effectuant des tests, nous nous sommes rendus compte que la
condition validant l'appui sur la touche Alt n'était pas nécessaire;
pourtant, le déclenchement de l'évent nécessitait toujours un appui
physique sur Alt.

Par la suite, le mainteneur à décidé de réécrire le patch pour ajouter
la vérification de la pression sur la touche Alt:

\begin{minted}[breaklines]{vala}
  if (((event.state & default_modifiers) == Gdk.ModifierType.MOD1_MASK) &&
  (((get_direction () == Gtk.TextDirection.LTR) && event.keyval == Gdk.Key.Left) ||
  ((get_direction () == Gtk.TextDirection.RTL) && event.keyval == Gdk.Key.Right))) {
    on_display_back ();

    return true;
  }
\end{minted}

\subsection{Retour à la collection avec la touch presedent de la souries}
L'ajouts de cette fonctionnalité nous à posser beaucoups de problème, non pas
pour la difficulté en terme de programation, mais pour des problèmes lié à la
documentation et a notre environement de développement.

Le premiers problème qui nous à fait perdre beaucoup de temps venez de notre
environement de developpement qui se trouve sur une VM (Virtual Machine).
Nous avons pris un moment avans de nous rendre compte que la souris n'étais
pas bien géré par \textit{Qemu}, il nous a donc falut lié le fichier de
la sourie \texttt{/dev/bus/usb/00x/00x} à notre VM affint quelle soit reconnus
nativement par l'OS de la VM.

De plus nous avons cherche pendant longtemps dans la documentation du langage
\textit{vala} la contante corespondant à la touche de la sourie que nous
voulions utilisé, mais nous n'avons rien trouvé, nous avons aussi demander
de l'aide sur le channel \textit{vala} de l'\texttt{irc} GNOME, mais nous
n'avons pas trouvé d'aide.

Au final nous avons ajouté un bout de code pour capter tous les evenements et
les affichers, ansi nous avons réussi à déterminé que le code de l'évenement
et le \texttt{8}.

Nous avons donc ajouté une ligne pour définire une fonction de callback pour
les appuis de bouton de la sourie.
\begin{minted}[breaklines]{xml}
<signal name="button-press-event" after="yes" handler="on_button_pressed"/>
\end{minted}

Nous avons aussi créer la fonction corespondante dont le but et de capté tous
les évenements corespondant au appuis sur les boutons de la sourie, si le
bouton appuié et le bouton de retour, executer la fonction préexistente
\texttt{on\_display\_back()} et retourner \texttt{true}.
Sinon retourné \texttt{false} pour propagé l'evenements et qu'il puisse être
traité comme par defaut.

Nous avons encore rencontré un ou deux petit problème, notament une erreur
dans la fonction que nous avions écrite, nous avons échenger le \texttt{true}
et le \texttt{false} pour le return, se qui veut dire que nous ne dissusont
l'evenement.
Résultat seuls notre evenement marche mais les autres sont détruit et jamais
traité.

Il nous à aussi étais demander d'ajouté un commentaire avant la valeur
\texttt{8} affins de gardé un code lisible. Le mainteneur a d'ailleur étais
surpris qu'il n'y ai pas de constant définie dans \textit{vala} ou dans
\textit{gdk} pour la touche présedente de la sourie, mais il n'a pas trouvé
de constante dans la documentation non plus. \\
\\
Voila la fonction tel qu'elle à étais intégré au projet :
\begin{minted}[breaklines]{vala}
[GtkCallback]
public bool on_button_pressed (Gdk.EventButton event) {
  // Mouse button 8 is the navigation previous button
  if (event.button == 8) {
    if (ui_state != UiState.DISPLAY)
      return false;

    on_display_back ();
    return true;
  }

  return false;
}
\end{minted}

\subsection{Bug configuration manette XBox360 et XBoxOne}
Un utilisateur de Games a déclaré un bug sur la fenettre de la configuration
des manette pour Games. Les appuis sur les touch TR2 et TL2 n'étais pas
reconues par le code de configuration.

Nous possédont un controleur Xbox360, nous avons donc chercher la source du
problème, mais sans message d'erreur, warning ou autre information, il à
étais un peut long de trouvé la source du problème.

Il s'est avéré que  le problème venait du type de bouton et des événements
liés à ces boutons. En effet, contrairement à d'autre modèles, les mannettes de
Xbox ont des boutons qui ne sont pas simplement appuyés et relachés, mais
ont une plage de valeurs possiblent et peuveut prendre plusieur sur un
axe unique.
%% ADD ILLUSTRATION ?
% David: terminer reformulation

Nous avons postés les informations que nous avons trouvé puis nous avons
commencés à réflechir à une solution pour corriger le problème. Entre temps un
autre contributeur a envoyé un patch très proche de la solution que nous
avions imaginés. Nous avons donc décidés de laisser faire le contributeur qui
fesait sa première contribution au projet. % <== LOL

Une partie du patch a été aceptée par le mainteneur, pour le reste il a
demandé des modifications mais le contributeur n'a pas encore tout corrigé.

A l'heure ou nous écrivons ces quelque ligne (3 mois après la déclaration
du bug), le patch et le bug sont toujours en attente des modifications du
contributeur.

\subsection{Correction de warning retro-gtk}
Lors d'une recompilation de la bibliothèque \textit{retro-gtk} nous avons
vu qu'il y avait des warnings dans la sortie de la compilation, nous
avons donc fait un patch pour les corriger. L'utilité de ce patch est limitée
dans le sens où les warnings que nous avons corrigés ne risquaient
pratiquement pas de causer un crash, mais cela permet toutefois d'avoir une
compilation plus propre.

\newpage
\section{Conclusion Gnome Games}
Ce projet nous a permis de nous accoutumer au développement
communautaire et ainsi de nous former à utiliser des outils
spécifiques tels que git ainsi que des trackeurs de bugs. Nous avons
aussi dû communiquer de manière directe avec la communauté GNOME,
notamment par IRC.

Nous avons fait différents patchs de code, qui on été accepté;
ainsi que des patchs de documentation, qui ont aussi été accepté.

Nous avons cependant rencontrés des difficultés de deux sortes,
celles-ci sont d'une part d'ordre technique, et d'autre part d'ordre
organisationnel.

Concernant ce dernier point, nous tenons à faire remarquer qu'il nous
a été difficile de concilier le fait d'avoir à travailler
conjointement sur le projet tuteuré et sur un projet spécifique dans
presque chacune des UE lors du second semestre.
Cela s'est vu amplifié par le fait que nous avons tous des niveaux techniques
assez disparates (cette remarque s'étend à la promotion), et que ce qui peut
être fait en deux heures pour l'un peut nécessiter deux jours pour
l'autre.
Il nous a été difficile de nous organiser et les heures de projet ont parfois
du être utilisées pour nous permettre de travailler sur les projets des
autres UE.

Et il est encore plus difficile pour les élèves alternant de concilier projet,
cours et travail dans l'entreprise.

De plus, nous ne somme pas tous développeurs, et ayants une expérience
limitée, la contribution nous demande beaucoup temps (pour étudier le code,
pour compiler correctement le projet, pour chercher des bugs à notre portée,
etc), chose qui nous a manquée lors de ce second semestre.

C'est notamment pour ces raisons que nous avons moins avancés que ce
que prévu lors du second semestre. Nous avions plusieurs projets de
contribution, que nous n'avons pas pu réaliser par manque de temps.

D'une manière plus générale, cette expérience fut très enrichissante car elle
nous a permis de nous rendre compte des difficultés inhérentes à
l'activité de contribution, que cela soit sur le plan technique, ou
sur le plan de la communication.

Elle nous à aussi permis de nous rendre utile à une communauté, et de nous
rendre compte que l'activité de contribution est difficile par bien des aspects,
qu'elle n'est pas réservé au développeur expérimenté mais que tous le monde peut
rajouter sa pierre à l'édifice pour permettre à la communauté et au logiciel
de grandir.

Et il est très probable qui nous ferrons des contributions dans le futur,
que se soit dans notre vie professionnelle ou personnelle.

\newpage
\section{Conclusion Gnome Music}

\chapter{Conclusion Générale}
%% Conclusion commun entre Music et Games

\end{document}
